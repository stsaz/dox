# Работаем с Аудио через Командную Строку на Linux и Windows

Если ты тоже, как и я, любишь возиться с аудио файликами, слушать, записывать, конвертировать и т.д., то эта статья для тебя.  Здесь я расскажу, как можно легко выполнять различные действия с аудио из командной строки, причём делать это одинаково удобно и эффективно и на Линуксах, и на Винде.  Для этого мы будем использовать программу fmedia.  Она кросс-платформенная и портативная, быстрая и не требует ничего лишнего - в общем, в самый раз для тех людей, кто одержим идеей разумной минималистичности и экономии ресурсов.

В чём в принципе бонус интерфейса командной строки перед графическим?

* Во-первых, все процессы легко автоматизируются.  Мы можем создать скриптик, который одним махом сконвертирует все аудио файлы в директории, или выведет список всех мета тэгов, или выполнит любую другую задачу с большим количеством файлов.

* Во-вторых, любую команду можно исполнять на удалённой машине, подключённой по SSH, например.

* К тому же, такие программы, как правило, гораздо менее требовательны к ресурсам компьютера, а это очень важно когда у нас есть только лишь старенький ноутбук.  Или когда мы слушаем музыку на ноуте, работающем на батарее, и требуется продлить его время работы.  Например, я на своём ноуте с Федорой могу хоть целый день слушать музыку на батарее через fmedia - реально надолго хватает заряда, главное - погасить экран.

* Нет никаких ограничений на максимальное количество файлов в активном плэйлисте.  Можно играть плэйлист с тысячей трэков, можно с миллионом - на скорость работы это никак не влияет.

> К слову, у fmedia всё таки есть графический интерфейс, но он опциональный, т.е. ты всегда сам решаешь, использовать графический интерфейс или же только командную строку.

Содержание:

* Устанавливаем программу
* Правила работы в терминале
* Записываем аудио
	* Записываем с другим форматом звука
	* Записываем с другого устройства
	* Записываем то, что сейчас воспроизводится на Винде
	* Записываем и останавливаем запись автоматически
	* Записываем в stdout
	* Записываем через асинхронный процесс
	* Автоматические имена выходных файлов
	* Записываем Интернет-радио поток
	* Записываем Интернет-радио трэки
* Воспроизводим аудио
	* Воспроизводим через другое устройство
* Конвертируем аудио файлы
	* Конвертируем с параметрами звука
	* Конвертируем с параметрами кодека
	* Конвертируем и задаём тэги
	* Делим один большой файл на маленькие
* Дополнительные функции
* Итоги


## Устанавливаем программу

Заходим на официальный сайт fmedia ([https://stsaz.github.io/fmedia/](https://stsaz.github.io/fmedia/)) и скачиваем архив с программой для Винды или Линукса.  Распаковываем архив в любую директорию на диске или на флэшке, и fmedia готов к работе.  Дополнительно ничего скачивать и устанавливать больше не надо - это очень удобно.

> Eсть вариант и сбилдить fmedia самостоятельно.  Для этого надо зайти на ГитХаб страницу проекта, почитать Ридми файл и повторить соответствующие шаги для сборки проекта мэйкфайлом.

### На Винде

Вообще, это не обязательно, но чтобы нам максимально удобно было вызывать бинарник fmedia, мы можем зарегистрировать его в системе.  Запускаем `cmd.exe` и выполняем такую команду:

	"D:\fmedia\fmedia.exe" --install

Естественно, вместо `D:\` у тебя здесь будет директория, куда ты только что распаковал архив.  Эта команда делает 2 вещи:

* Добавляет путь `D:\fmedia` в `%PATH%`.
* Создаёт ярлык на рабочем столе к `fmedia-gui.exe` (это GUI к fmedia, но про него мы здесь говорить не будем).

Отлично, теперь мы можем из любой директории в консоли просто выполнять команды через `fmedia`.

### На Линуксе

На Линуксе команда `--install` не работает, поэтому мы можем вручную создать ссылку на бинарник:

	ln -s ~/bin/fmedia-1/fmedia /usr/local/bin/fmedia

Это если мы распаковали архив в `~/bin`.  Результат тот же, что и на Винде: теперь мы можем выполнять команды в консоли через `fmedia`.

### Конфигурим программу

Обычно ничего настраивать не надо - всё и так должно работать.  По умолчанию на Винде используется WASAPI аудио подсистема, а на Линуксе - PulseAudio и ALSA.  Все настройки лежат в файле `fmedia.conf`, fmedia его читает при запуске, поэтому если ты меняешь конфиг, то надо перезапустить fmedia.  Все поддерживаемые аргументы командной строки можно посмотреть, если запустить `fmedia -h`.

> Имей в виду, что у fmedia немало настроек и параметров командной строки.  Всего очень много различных вариантов использования, рассказать про которые не хватит времени и места.  Я в этой статье привожу лишь самое полезное на мой взгляд.

## Правила работы в терминале

Все приведённые в статье команды почти идентичны и на Линуксе и на Винде, но с одной лишь оговоркой.  Терминалы на этих ОС всё же разные, поэтому если мы хотим использовать пробелы в командах или специальные символы, мы должны помнить что:

* На Линуксе (в sh или bash) надо использовать одинарные кавычки (''), например:

		fmedia 'my file.ogg'
		fmedia file.wav -o '$filename.ogg'

* А на Винде (в cmd.exe) - двойные кавычки (""), например:

		fmedia "my file.ogg"

В этой статье я привожу все команды с одинарными кавычками, т.к. я обычно на Линуксе работаю.


## Записываем аудио

Обычно записывать звук через fmedia очень легко, нужно лишь указать ключик `--record` и имя выходного файла:

	fmedia --record -o rec.flac

Тут мы начинаем записывать со звукового устройства по умолчанию в файл `rec.flac` в формате FLAC.  Чтобы писать в другой формат файла, просто задай желаемое расширение: .wav, .flac, .m4a, .mp3, .ogg, .opus.  Например, вот как нужно записывать в AAC-LC в MP4 контейнер:

	fmedia --record -o rec.m4a

Для того, чтобы остановить запись, нажимаем клавишу `s` (что соответствует команде Stop) или `Ctrl+C`.

Пример запуска:

	$ fmedia --record -o rec.m4a
	φfmedia v1.27.3 (linux-amd64)
	Recording...  Source: int16 44100Hz stereo.  Press "s" to stop.
	0:04  [======....] -12.45dB / 0dB
	18:19:20.103 :40ef [info] fmt.mp4-write: *1:    MP4: frames:181, overhead: 1.17%
	saved file rec.m4a, 132 kbytes


### Записываем с другим форматом звука

Если никаких параметров не указано, по умолчанию мы используем формат звука int16/44100Hz/stereo (так указано в конфиге - мы можем это изменить, при необходимости).  Вот как мы можем задать другой формат:

	fmedia --record --format=int24 --channels=mono --rate=48000 -o rec.wav

Здесь мы пишем звук в формате int24/48000Hz/mono в .wav файл.


### Записываем с другого устройства

Если у нас несколько устройств звукозаписи, то вот как мы можем записывать именно с того устройства, с которого хотим.  Первое - получаем список всех доступных устройств:

	fmedia --list-dev

Далее, выбираем номер нужного нам устройства из секции `Capture:`, например #2, и пишем звук с него:

	fmedia --record --dev-capture=2 -o rec.flac


### Записываем то, что сейчас воспроизводится на Винде

На Винде у WASAPI есть крутая возможность вести запись "изнутри" (Loopback режим).  Т.е. то, что любая другая программа на Винде на данный момент играет через колонки - мы это можем считать и записать в файл.  Удобно для записи звука из браузера, или из игры, или из чего угодно.  Активируется эта фича через ключ `--dev-loopback`:

	fmedia --record --dev-loopback=0 -o rec.wav

Здесь мы записываем из устройства по умолчанию.  Если вдруг хотим использовать другое устройство, опять вначале листим все устройства:

	fmedia --list-dev

И выбираем нужное устройство из секции `Playback/Loopback:`.  Например, используем устройство #2:

	fmedia --record --dev-loopback=2 -o rec.wav

> Вообще, WASAPI не выдаёт пользовательским программам никаких данных в Loopback режиме, если никто в системе ничего не воспроизводит.  Но fmedia автоматически заполняет это пространство тишиной.

А вот более сложный пример, тут мы записываем одновременно 2 разных файла, один поток - из микрофона, второй - из браузера, используя устройство записи #1 и устройство воспроизведения #2:

	fmedia --dev-capture=1 --dev-loopback=2 --record -o "rec-$counter.wav"

Что такое `$counter` - это переменная для автоматического именования файлов.  Суть в том что fmedia создаст 2 файла - `rec-1.wav` и `rec-2.wav`.


### Записываем и останавливаем запись автоматически

Когда мы хотим писать звук в файл строго определённое количество времени, мы используем параметр `--until`.  Например, пишем 60 секунд, затем останавливаемся автоматически:

	fmedia --record -o rec.flac --until=60

До истечения этого времени тоже можно нажать `s`, чтобы прервать запись раньше, но это теперь не обязательно.


### Записываем в stdout

Бывает полезно использовать fmedia для записи аудио, а затем сразу передавать записанные данные в другую программу.  Для этого есть возможность записи в stdout поток.  Активируем эту фичу, передавая `-o @stdout.wav` параметр.  Например, записываем в .wav файл из stdout потока:

	fmedia --record -o @stdout.wav >rec.wav

Или передаём данные напрямую в другой процесс:

	fmedia --record -o @stdout.wav | your_audio_app OPTIONS


### Записываем через асинхронный процесс

Есть возможность управлять запущенным процессом записи асинхронно, т.е. из другого терминала.  Работает это следующим образом.  Вначале запускается основной fmedia процесс, который начинает записывать звук.  Он создаёт системный канал (pipe), из которого он может принимать команды от других процессов.  Затем, в любой момент мы можем послать команду остановки записи, запустив новый процесс fmedia.  После принятия этой команды, первый процесс завершит запись и закроется.

Приказываем fmedia записывать звук и слушать команды от других процессов через:

	fmedia --record -o rec.wav --globcmd=listen

В любой момент из другого терминала мы можем остановить звукозапись:

	fmedia --globcmd=stop

> Почему нельзя просто взять и убить первый процесс fmedia, который записывает в файл?  У большинства аудио файлов есть мета информация, например количество сэмплов аудио (т.е. длительность аудио).  Если процесс взять и убить, то мы не дадим возможности fmedia правильно сохранить эту мета информацию, из-за чего файлы могут оказаться нечитабельными из обычных программ-плееров.


### Автоматические имена выходных файлов

Чтобы не придумывать и не писать каждый раз имена для выходных файлов, просто будем именовать их автоматически, по текущему системному времени:

	fmedia --record -o 'rec-$time.wav'


### Записываем Интернет-радио поток

Обычно Интернет-радио используют протокол ICY, внутри которого гоняют обычный MPEG1 Layer3.  Запишем этот поток себе в файл без декодирования (без потери качества):

	fmedia 'http://radio-stream:80/' -o radio.mp3 --stream-copy

Здесь ключ `--stream-copy` говорит о том, что мы НЕ хотим конвертировать аудио, а просто скидывать MP3-фреймы как есть.  Мы сможем сохранить понравившуюся песню, или нам нужно на время отлучиться от компа, а онлайн трансляция очень важная - мы её сохраним и позже послушаем.

То же самое, но одновременно воспроизводить радио поток через колонки:

	fmedia 'http://radio-stream:80/' -o radio.mp3 --stream-copy --out-copy

Т.е. мы будем слушать радио, но в то же время сохранять все фреймы в файл.


### Записываем Интернет-радио трэки

В протоколе ICY предусмотрена простенькая возможность прокидывать мета информацию о названии трэка и исполнителя.  Некоторые сервера устанавливают мета данные, а мы можем использовать эту информацию для автоматического дробления потока на файлы с правильными именами.  Эта команда будет создавать по одному файлу на каждый трэк, именуя это так: `Время. Исполнитель - Название.mp3`:

	fmedia 'http://radio-stream:80/' -o '$time. $artist - $title.mp3' --out-copy --stream-copy

А вот так мы можем записывать не каждый трэк, а только те, которые нам понравились:

	fmedia 'http://radio-stream:80/' -o '$time. $artist - $title.mp3' --stream-copy --out-copy-cmd

Пока играет трэк, мы можем нажать `Shift+t` комбинацию, и этот трэк сохранится на диске.

> Я не юрист, но вроде бы обычно трансляции не разрешают слушателям сохранять поток и использовать его как захочется.  Весь мир свихнулся на авторских правах, роялти и всякой другой современной капиталистической дряни...  Поэтому, если сохраняешь поток с радио, то слушать можно только самому дома и нигде не транслировать.


## Воспроизводим аудио

Слушать музыку через fmedia очень просто.  Указываем входные файлы, которые мы хотим играть, один за другим.  Например, воспроизводим отдельные файлики, или группы файлов:

	fmedia ./file.ogg ./*.mp3

На текущий момент поддерживаются следующие контейнеры и кодеки: .mp3, .ogg (Vorbis/Opus), .opus, .mp4/.m4a/.mov (AAC/ALAC/MPEG), .mka/.mkv/.webm (AAC/ALAC/MPEG/Vorbis/Opus/PCM), .caf (AAC/ALAC/PCM), .avi (AAC/MPEG/PCM), .aac, .mpc, .flac, .ape, .wv, .wav.  А также плейлисты: .m3u, .pls, .cue.

Воспроизводим все файлы внутри директории:

	fmedia ./Music

Воспроизводим Интернет-радио:

	fmedia 'http://radio-stream:80/'

Воспроизводим аудио из stdin потока:

	cat input.wav | fmedia @stdin.wav

Пример использования:

	$ fmedia rec.wav
	φfmedia v1.27.3 (linux-amd64)

	#1 " - " "rec.wav" 0.70MB 0:04.134 (182,344 samples) 1411kbps WAVE int16 44100Hz stereo

	[=================...............................................] 0:01 / 0:04


### Воспроизводим через другое устройство

Если хотим, чтобы игралось не через устройство по умолчанию, а через другое устройство, то аналогично со звукозаписью, вначале получаем список устройств:

	fmedia --list-dev

Затем указываем номер устройства, через которое хотим воспроизводить, например устройство #2:

	fmedia file.ogg --dev=2


## Конвертируем аудио файлы

Конвертация выглядит достаточно просто: на вход подаём список файлов, которые хотим конвертировать.  По желанию, указываем настройки для аудио кодека.  По умолчанию, используются настройки кодеков из `fmedia.conf`.  И наконец, указываем выходной аудио формат для новых файлов.  Например, конвертируем WAVE в MP3:

	fmedia rec.wav -o rec.mp3

Можем не писать имя выходного файла, а генерировать его автоматически:

	fmedia rec.wav -o '$filename.mp3'

`$filename` - автоматически использовать имя (без расширения) входного файла.

Сконвертируем все WAVE файлы в текущей директории в OGG Vorbis:

	fmedia ./*.wav -o '$filename.ogg'

То же самое, но кладём выходные файлы внутрь новой директории:

	fmedia ./Music/*.wav -o 'Encoded/$filename.ogg'

Сконвертируем все файлы из списка внутри Music.m3u8:

	fmedia --flist=Music.m3u8 -o '$filepath/$filename.ogg'

`$filepath` - автоматически подставлять полный путь до входного файла.


### Конвертируем с параметрами звука

Конвертируем в WAVE, используя int16 формат сэмпла (вместо float32, который использует Vorbis декодер):

	fmedia file.ogg -o file.wav --format=int16

Конвертируем в int16/48000Hz/stereo:

	fmedia file.ogg -o file.wav --format=int16 --rate=48000 --channels=stereo

> Учти, что не все конфигурации конвертации поддерживаются, например не работает конвертация с форматом сэмпла int24 вместе с конвертацией sample rate.  Тут проблема в том, что библиотека libsoxr, использующаяся для конвертации сэмпл рэйта, int24 не поддерживает, а fmedia не умеет это ограничение обходить.

Можно увеличить громкость на +6 dB, если запись слишком тихая:

	fmedia in.wav --gain=6.0 -o louder.wav

Или уменьшить громкость на -6 dB:

	fmedia in.wav --gain=-6.0 -o silent.wav

Можно применить динамический фильтр, уравнивающий громкость по алгоритму Гаусса:

	fmedia in.wav --dynanorm -o normalized.wav

Кстати, у этого фильтра немало настроек - задать их можно в `fmedia.conf`.  И кстати, автор этого фильтра (Dynamic Audio Normalizer) вроде бы тоже немец, как и величайший математик Карл Гаусс.


### Конвертируем с параметрами кодека

Почти у каждого кодека есть параметры, которые мы можем задавать через командную строку.

Так для Vorbis задаём качество VBR 7 (что примерно соответствует 200kbit/s):

	fmedia file.wav -o file.ogg --vorbis.quality=7.0

Так для Opus задаём качество VBR 256kbit/sec:

	fmedia file.wav -o file.opus --opus.bitrate=256

Так для MPEG Layer3 задаём качество CBR 256kbit/sec:

	fmedia file.wav -o file.mp3 --mpeg-quality=256

Так для MPEG Layer3 задаём качество VBR q=2:

	fmedia file.wav -o file.mp3 --mpeg-quality=2

Так для AAC-LC задаём качество VBR q=5 (что примерно соответствует 210kbit/s):

	fmedia file.wav -o file.m4a --aac-quality=5

fmedia использует официальные опен-сорс аудио энкодеры, это библиотеки libfdk-aac, libFLAC, libmp3lame, libopus, libvorbisenc.  Так что скорость конвертации полностью зависит от них.


### Конвертируем и задаём тэги

Можно конвертировать и заодно изменить мета тэги, например зададим тэги "Исполнитель" и "Название":

	fmedia file.flac -o file.ogg --meta='artist=Исполнитель;title=Название'

Остальные тэги при этом сохранятся.  А вот как сделать так, чтобы все оригинальные тэги стереть:

	fmedia file.flac -o file.ogg --meta='clear;artist=Исполнитель;title=Название'

Т.е. мы тут добавили `clear;` в начало команды `--meta`.


### Делим один большой файл на маленькие

Отрежем начальные 35 секунд у файла, сохранив всё остальное:

	fmedia big.wav --seek=00:35 -o cut.wav

Сохраним первые 01:35, удалив всё остальное:

	fmedia big.wav --until=01:35 -o cut.wav

Вырежем кусок от 00:35 до 01:35:

	fmedia big.wav --seek=00:35 --until=01:35 -o cut.wav

Чтобы разделить один большой файл (например, альбом) на трэки, воспользуемся .cue файлом:

	fmedia album.flac.cue -o '$tracknumber. $artist - $title.flac'

Если нужно сохранить только выборочные трэки, то делаем например так:

	fmedia album.flac.cue --track=3,7,13 -o '$tracknumber. $artist - $title.flac'

Т.е. через запятую с параметром `--track` указываем какие трэки хотим сконвертировать.  Кстати, у fmedia есть и настройка, чтобы контролировать прегапы в трэках в .cue файлах, это ключ `--cue-gaps`.  По умолчанию прегапы добавляются в конец предыдущих трэков.

Можно поделить файл на равномерные по длительности куски, например делим большой файл на файлики по минуте каждый:

	fmedia big.wav --split=01:00 -o 'file-$counter.wav'

Для некоторых кодеков есть возможность вырезать куски аудио без потери качества, например для .mp3, .ogg и .m4a.  Для этого добавляем ключ `--stream-copy` к команде, например:

	fmedia big.ogg --seek=1:00 --until=2:00 --stream-copy -o cut.ogg


## Дополнительные функции

Просто распечатать мета информацию из файла (например длительность, битрейт и название кодека):

	fmedia --info file.mp3

То же, но ещё распечатать все мета тэги:

	fmedia --info --tags file.mp3

Иногда бывает полезно проанализировать все сэмплы в файле.  Делаем это с ключом `--pcm-peaks`:

	fmedia input.ogg --pcm-peaks

Пример использования:

	$ fmedia --pcm-peaks rec.wav
	φfmedia v1.27.3 (linux-amd64)

	#1 " - " "rec.wav" 0.70MB 0:04.134 (182,344 samples) 1411kbps WAVE int16 44100Hz stereo

	[===================================================.............] 0:03 / 0:04
	"rec.wav":
	PCM peaks (182,344 total samples):
	Channel #1: highest peak:0dB, avg peak:-26.02dB.  Clipped: 78 (0.0428%).  CRC:00000000
	Channel #2: highest peak:0dB, avg peak:-24.71dB.  Clipped: 62 (0.0340%).  CRC:00000000

Можно сгенерировать чексумму аудио данных - это бывает полезно, чтобы убедиться в оригинальном качестве после конвертации:

	fmedia *.flac --pcm-peaks --pcm-crc

Ну и в качестве бонуса, вот как можно быстро сгенерировать M3U плэйлист из директории:

	fmedia ./Music -o music.m3u8


## Итоги

Теперь ты знаешь как минимум ещё один способ как сделать что-то полезное с аудио контентом.  Понятно, что какие-то из приведённых здесь советов легко заменяются скриптами и командами для великого ffmpeg, но лично для меня fmedia во многом удобнее.  (ffmpeg очень силён, когда дело касается видео файлов, но эта статья именно про аудио).  В целом, под любую команду можно создать какой-нибудь алиас, чтобы ещё проще было запускать конвертацию или запись из командной строки.  Например, для bash на Линуксах можно добавить в `~/.bashrc`:

	alias rec='fmedia --record -o rec.wav'

А для Винды можно скрипт файл создать, например `rec.cmd`:

	fmedia --record -o rec.wav

Но ты это наверняка уже и так понимаешь, так что на этом я заканчиваю эту статью.  Надеюсь, хоть что-то да было тебе полезно.
